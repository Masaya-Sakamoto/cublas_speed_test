# データ集計プログラム依頼

## 依頼概要
以下依頼概要を箇条書きで説明する:
- pythonでプログラムを作成してください。
- このプロジェクトディレクトリのルートディレクトリ直下にpythonというディレクトリがあるので全ての実行プログラム他は全てこの下につくること
- 集計にはsqliteを使用すること

## 事前知識
まず、docs/*.mdの内容を参照してください。

## 試行プログラム概要
計測に用いるプログラムはそれぞれcblas_col_speed_test.cpp, cblas_row_speed_test.cpp, cublas_speed_test.cuです。それぞれのプログラムをビルドすると、その実行時に行列の大きさを表す3つの整数M, N, Kと、実行回数nを引数として認識するプログラムが作成されます。
```bash
cd lib
./build.sh    # プログラムがビルドされる
```
するとlib/build内に次のプログラムが生成される:
- cblas_col_speed_test
- cblas_row_speed_test
- cublas_speed_test

プログラムの実行方法
```
<*blas_speed> M N K n
```

このプログラムを実行すると行列の計算にかかった時間のn回算術平均、標本標準偏差、（主にGPUに対して）デバイスにメモリコピーするためにかかった時間n回算術平均、その標本平均、デバイスからホストにメモリコピーするためにかかった時間n回算術平均、その標本平均がカンマ分けで標準出力されます。
```
<*blas_speed> M N K n
<実行時間平均>,<実行時間誤差>,<デバイスコピー時間平均>,<デバイスコピー時間誤差>,<ホストコピー時間平均>,<ホストコピー時間誤差>
```

## M, N, K選択方法
集計プログラムを実行するときにM_min, M_max, N_min, N_max, K_min, K_maxを引数として渡すようにしてください。
全ての組み合わせを調査するととても長い時間がかかるため、実験計画法で推定する。ただし、M*K, K*N, M*Nはすべて32の倍数になるようにする。

## 開発にあたっての注意事項
- 実行前にこの依頼書を元にしたdesign docをdocsディレクトリ直下に作成すること
- design docを元に計画書をdocsディレクトリ直下に作成すること
- 疑問点がある場合は質問すること
- こまめにgitリポジトリにコミットすること



> gpt-4o
Pythonでデータ収集プログラムを作成するために、以下の手順に従います。  

### **設計ドキュメント**  
- `docs/` ディレクトリ内に設計ドキュメントを作成し、データ収集プログラムの構造と機能を概説します。  
- このドキュメントには、以下の内容を含めます。  
  - 既存の測定プログラム（`cblas_col_speed_test`、`cblas_row_speed_test`、`cublas_speed_test`）との連携方法  
  - SQLiteを使用したデータの収集および保存方法  
  - 行列サイズや繰り返し回数の入力パラメータの処理方法  

### **プログラム構成**  
- Pythonプログラムは `python/` ディレクトリ内に作成します。  
- 以下の機能を含めます。  
  - 指定されたパラメータで測定プログラムを実行  
  - 測定プログラムの出力を解析  
  - 結果をSQLiteデータベースに保存  
  - 行列サイズや繰り返し回数の入力パラメータを処理（`M*K`、`K*N`、`M*N` が32の倍数であることを保証）  

### **実装計画**  
Pythonプログラムを以下の段階で実装します。  

1. **実行モジュール**: 測定プログラムを実行し、その出力を取得するモジュールを作成  
2. **解析モジュール**: 出力を解析し、必要なデータを抽出するモジュールを作成  
3. **データベースモジュール**: 抽出したデータをSQLiteデータベースに保存するモジュールを作成  
4. **メインプログラム**: 各モジュールを統合し、ユーザー入力を処理しながらデータ収集を管理するプログラムを作成  

### **頻繁なコミット**  
進捗をGitリポジトリに頻繁にコミットし、バージョン管理と追跡を確実に行います。  

### **質問**  
- SQLiteデータベースのフォーマットや構造に関して、特定の要件はありますか？  
- データの可視化やレポート作成など、追加機能を含めるべきでしょうか？  

設計ドキュメントを作成・レビューした後、実装に進みます。  
計画を確認し、変更点や追加要件があればお知らせください。

> わたし:  
はい。問題ありませんので進めてください。ただし、以下の内容に注意してください。
- 実行計画は特に実行テストと検証を通じて品質を向上させるように努めてください。
- M, N, Kを設定するにあたり、それまでの結果から実験計画法で、より有意な検証ができるように注意してください。

<!--
> わたし:  
現在の`main_program.py`のプログラムは以下のようになっています：
```python
    for M in range(M_min, M_max + 1, 32):
        for N in range(N_min, N_max + 1, 32):
            for K in range(K_min, K_max + 1, 32):
                try:
                    validate_parameters(M, N, K)
                    output = execute_program(program_path, M, N, K, iterations)
                    results = parse_output(output)
                    store_results(db_path, M, N, K, iterations, results)
                except ValueError as e:
                    print(f"Skipping invalid parameters M={M}, N={N}, K={K}: {e}")
                except Exception as e:
                    print(f"Error processing M={M}, N={N}, K={K}: {e}")
```
これを、既存の集計結果からガウス過程で平均の計算時間の推定値を計算し、推定された平均の計算時間の分散が最大になるM_float, N_float, K_floatが計算できます。M_float, N_float, K_floatの近くの整数点(M, N, K)が前述の条件：M*Kが32の倍数でかつK*Nが32の倍数でかつM*Nが32の倍数を満たす場合に、そのM, N, Kで新たに計測するように変更してください。
-->

> わたし:  
実施計画を管理できるようにしたいです。私が現在考えている方式を示します:
1. exec_id, M, N, K, statusのsqliteデータベースを作成する。
2. 実験をする際にはそのデータベースから、statusが未実行のrowからM, N, Kを取り出して、実験を行う。
3. 実験の終了とともにstatusを変更するようにしたいです。

先ず、その様なプログラムに改良するための計画を立てましょう。

<!--
TODO:
- スケジュールデータベースに優先クラスカラムを作る
    - jobのnice値のようなものを想定している
    - 優先クラスがついているものとそうでないものに分けて考える
    - 優先クラスがついているものの中で探索し、その結果を元に新たに優先クラスがついているスケジュールを選択する
    - 優先クラスがついているスケジュールがない場合、ランダムで実行する
- スケジュールデータベースに条件を満たすM, N, Kを全て入れる
- 実行計画更新グリッドを設定する関数をつくる
- 実行プログラムごとに実行スケジュールを個別に設定する
- プログラムの変更とデータベースの変更を容易に行うことができるようにする
- 実行プログラムのリストを外部のファイル(JSONなど）から読み出すようにする

[プログラム別の実行計画]
1. パラメタデータベースを作成する
2. パラメタデータベースの初期化関数を作成する
3. スケジュールのパラメタ設定をパラメタデータベースのIDと紐付ける
4. スケージュールに紐付いたパラメタを利用するように変更する
5. スケジュールにnice値を設定できるようにする
6. スケージュールデータベースには、パラメタデータベースからM * N * Kの昇順で登録するように変更
~ 7. nice値の指定があって、優先度の高いものから実行するように変更 ~
# ここからプログラムを個別に実行＆計測、記録するために必要な実装をしていく
8. 実行結果をまとめたデータベースを生データの記録と、集計結果をまとめたものに分割する
~ 9. データベースのテンプレートを作成する ~
10. 実行プログラムをbuildディレクトリから参照してYAMLファイルを作成する
11. YAMLファイルから対応する実行計画データベースを作成する: initialize_parameters.pyを実行する
12. `critical_params.yml`を読み込んでスケジュールデータベースの優先度を更新する関数を作成する
13. `if __name__ == "__main__":`を書き換えて、全ての検証用プログラムを実行するようにする

# ここまでで一区切り。ここから先は自動探索できるようにする改造
以下プログラム動作に関して
1. パラメタの最小値と最大値をファイルから読み出すようにする
2. ガウス過程で不確かな点を探索する
3. 点近傍の8点で実験(2^dims点で実験。今回はM, N, Kの３次元)
4. 11に戻る
5. 不確かさが閾値より小さくなるか、全整数点を検索すれば終了するようにする
-->

## 1. パラメタデータベースを作成する
> わたし:  
スケジュールデータベースにパラメタを直接記述することを取りやめて、新たに作成するパラメタデータベースと紐付けることにします。
そのために必要なプランを作成して、そのプランをdocs/ディレクトリ以下にmarkdown形式で保存してください。
- パラメタデータベースのカラムはid, M, N, Kであるとします。
- スケージュールデータベースが今までM, N, Kを持っていましたが、この変更のためパラメタデータベースのIDを持つことで代替します。
- 実験結果を収めたデータベースも同様にM, N, Kをパラメタデータベースの当該IDで置き換えます。

## 2. パラメタデータベースの初期化関数を作成する
> わたし:  
パラメタデータベースを初期化する関数を作ってください。このときM, N, Kのリストを受け取り、それぞれの要素に対してidを割り当ててデータベースに挿入するようにしてください。つまり作業内容は以下の通りです：
1. 新規作成する関数はm_list, n_list, k_listを受け取る。
2. for M, for N, for Kの３重ループでそれぞれの要素に対してidを割り当ててデータベースに挿入する。  

以上の作業が完了したら、この作業の目的と変更についてmarkdown形式のドキュメントをdocs/ディレクトリ直下に作成してください。

## 3. スケジュールのパラメタ設定をパラメタデータベースのIDと紐付ける

> わたし:  
このプログラムでは先ずパラメタデータベースがあって、そこからスケジュールを作成、そして実験、結果を結果のデータベースに保存という流れなので、スケジュールに未登録のパラメタがパラメタデータベースに存在しない場合はスケジュールを全て実行した後にメインプログラムが正常終了するようにしてください。したがって、メインプログラムに現在記述されたスケジュールが存在しない場合のループは不要です。

## 4. スケージュールに紐付いたパラメタを利用するように変更する

> わたし:  
不具合修正依頼です。mainプログラムで`schedule_exists`がない場合次のようになっています。
```python
    if not schedule_exists:
        for parameter_id in range(1, len(range(M_min, M_max + 1, 32)) * len(range(N_min, N_max + 1, 32)) * len(range(K_min, K_max + 1, 32)) + 1):
            insert_schedule(db_path, parameter_id)
```
parameter_idを`range`関数から取得していますが、これをパラメタデータベースから取得するようにしてください。つまり、以下のようにすると良いと思います：
1. パラメタデータベースの`id`集合の内で、スケジュールデータベースの`parameter_id`集合に存在しないものを取り出す。これがスケジュールデータベースに未登録なparameter_idになります。　
2. 取り出した未登録なparameter_idをスケジュールデータベースに登録し、同時にその行の`status`を
3. 再度スケジュールデータベースを確認して、新たに`schedule_exists`を取り出す。

また、パラメタデータベースはこのメインプログラムを実行する以前に初期化されていなければなりません。したがって、パラメタデータベースの初期化は`main_program.py`とは別のプログラムファイルにしてしまうことが良いと考えます。

上記内容サマリーと、今の所私が思いついている作業範囲を書きます。
- パラメタデータベース初期化用に新たなプログラムファイルを作成する。
- `insert_parameter`関数をparameter_database_module.pyに作成して、パラメタを登録できるようにする。
- `insert_schedule`関数の実装をparameter_idを用いるように修正する。
- mainプログラムを修正する。

> わたし:  
加えて、パラメタデータベースの`id`リストと、スケジュールデータベースの`parameter_id`リストを比較して差分を抽出するクエリを書いて、差分をリストにする関数を追加する必要があると考えました。

> わたし:  
差分を取り出す関数はどのファイルに記述することが良いと考えますか？

## 全体見直し
> わたし:  
ありがとうございます。では次の作業に移りましょう。
いくつかのプログラムファイルが現在の仕様と適合していません。したがってここまでのプログラムの仕様について一度まとめて、それからプログラムファイルを確認して仕様と異なる部分を修正しましょう。

> わたし:  
ありがとうございます。少し修正依頼があります。
`check_schedule`関数はもともと前のバージョンのスケジュールデータベースが現在のスケジュールデータベースとパラメタデータベースの両方の役割を担っていたため存在しました。しかし、現在はデータベースの役割が分割されています:
- `result`は結果を保管するためのデータベースで、`id`, `parameter_id`, `iterations`, `execution_time_avg`, `execution_time_err`, `device_copy_time_avg`, `device_copy_time_err`, `host_copy_time_avg`, `host_copy_time_err`のカラムがあります。
- `schedule`は実行スケジュールを管理するためのデータベースで、`exec_id`, `parameter_id`, `status`のカラムがあります。
- `parameters`はパラメタを管理するデータベースです。`id`, `M`, `N`, `K`のカラムがあります。
そのため、`check_schedule`と`extract_unexecuted_rows`の役割が重複しています。名前と、実装箇所から判断して`check_schedule`に統一しましょう。
加えて、上記の修正を行うと`main_program.py`の下記部分に修正が必要です。
```python
    schedule_exists = check_schedule(db_path)

    if not schedule_exists:
        unregistered_parameters = list_unregistered_parameters(db_path)
        for parameter_id in unregistered_parameters:
            insert_schedule(db_path, parameter_id)

    unexecuted_rows = extract_unexecuted_rows(db_path)
    for row in unexecuted_rows:
```
動作は次のようにしたいです。
1. `check_schedule`で未実行パラメタidリストを取得する
  1.1. もし未実行パラメタidリストが空だった場合、パラメタデータベースを参照する。
  1.2. スケジュールに追加できるパラメタidリストを取得できた場合はスケジュールに未実行状態にして追加する。
  1.3. スケジュールに追加した場合は再度`check_schedule`を実行してパラメタidリストを更新する。
2. 取得したパラメタidリストでパラメタデータベースを参照してパラメタを取得する
3. 取得したパラメタで実験する
4. 実験結果を整理する
5. スケジュールを更新する。

## 5. スケジュールにnice値を設定できるようにする

> わたし:  
ご尽力ありがとうございました。実は前回の会話の後に追加した部分もあります。変更内容を理解するには、docs/bugfix_log の直下にある `parameter_id_after_conversation.diff` を参照してください。
では、次のタスクに進みます。  
スケジュール データベースに優先度を表す列を追加します。優先度は、linuxにおけるプロセスの`nice`値のようなものを想定しています。  
変更による影響の範囲を確認し、機能追加の方策を検討してください。

## 6. スケージュールデータベースには、パラメタデータベースからM * N * Kの昇順で登録するように変更

> わたし:  
どうもありがとうございます。nice値を設定できるようになりましたね！では次は機能をモディファイしましょう。
今回の改良目的は、パラメタデータベースからスケージュールデータベースに登録するときに`M`, `N`, `K`の積`M * N * K`の昇順で（つまり実行順を`M * N * K`が小さいものから大きいものへ）登録することです。
今回のプロジェクトの目的が`lib/build/`ディレクトリ直下に存在する3つのプログラム`cblas_col_speed_test`, `cblas_row_speed_test`, `cublas_speed_test`の実行時間を測定することでしたね。このプログラムはM, N, Kが大きくなると、その積に比例して実行時間が長くかかることが事前に分かっています。
そこでできるだけ速く全体の傾向を調べるに`M * N * K`が小さいものから検証していくことにします。
そこで、現在の`main_program.py`で直接スケージュールを構成している現在のプログラム:

```python
    if not unexecuted_rows:
        unregistered_parameters = list_unregistered_parameters(db_path)
        for parameter_id in unregistered_parameters:
            insert_schedule(db_path, parameter_id, priority=0)
        unexecuted_rows = check_schedule(db_path)
```

と`schedule_database.py`を変更してください。少し具体的に説明すると、`unregistered_parameters`を調べてそれを`for`ループで回していますが、この部分をまるごと関数にして`schedule_database_module.py`に配置しましょう。そして、その関数の中身を目的に合わせて変更してください。  
では内容に準じた改良プランを作成してください。

~7. nice値の指定があって、優先度の高いものから実行するように変更~

## 全体見直し2  

> わたし:  
はい、全く問題ありません。素晴らしい出来栄えです！   
これまでの作業を再度見直してみましょう。これまでの作業は実は以下の作業スケージュールで進めてきました：

```markdown
1. パラメタデータベースを作成する
2. パラメタデータベースの初期化関数を作成する
3. スケジュールのパラメタ設定をパラメタデータベースのIDと紐付ける
4. スケージュールに紐付いたパラメタを利用するように変更する
5. スケジュールにnice値を設定できるようにする
6. スケージュールデータベースには、パラメタデータベースからM * N * Kの昇順で登録するように変更
```

全体を確認して計画に沿っていることを一緒に確認しましょう。

## 8. 実行結果をまとめたデータベースを生データの記録と、集計結果をまとめたものに分割する

> わたし:  
尽力いただき感謝します。こちらでもプロジェクトの進行状態を確認しました。しかし次からは共にプログラムを見ながら、要点をまとめて、実際にプログラムが正しく実装されているかステップバイステップで確認してみましょうね。でも今回は確認が取れたので確認作業はこれ以上行いません。  
では次の作業に移りましょう!  
今回は、結果を記録する`results`テーブルをより使い勝手が良くなるように改良しましょう。これまではプログラム自体が実行結果を集計して標準出力に表示していましたが、これからはプログラム自身で集計せずに一度生データを他のテーブルに登録して、それをSQLとPythonスクリプトで集計して`results`に保管するようにしましょう。
計測対象のプログラムは全て次のような標準出力をするように改造しました。
```shell
$ ./<evaluating_program>
<実行時間:double値>,<ホストからデバイスへ向けてメモリコピーにかかった時間:double>,<デバイスからホストへ向けてメモリコピーにかかった時間:double>
<実行時間:double値>,<ホストからデバイスへ向けてメモリコピーにかかった時間:double>,<デバイスからホストへ向けてメモリコピーにかかった時間:double>
# このあとイテレーション回数だけ同じように続く..
```

したがって、作業内容の概要は以下のように成ると思います。
- 複数行のカンマ区切りされた3つのdouble値を読み取る
- 読み取った3つの値と、パラメタidをまとめて生データ保管テーブルにインサートする
- 生データテーブルから同じパラメタidを持つものを抽出する
- それぞれの平均と標本標準偏差を計算して`results`テーブルにインサートまたは値の更新を行う

上記内容を踏まえて、実際の作業計画を立案してください。

> わたし:  
素晴らしい作業の出来栄えですが、3点修正したほうがより良くなると思いました。
- `main_program.py`に集計を行うロジックを直接記述せずに、`database_module.py`の関数として実装したほうが保守性が向上すると思いました。
- すでに`results`テーブルに同じ`parameter_id`の行が存在する場合、`ON CONFLICT(parameter_id) DO UPDATE`が有用かもしれません。
- 集計にはnumpyかmathで実装された関数を利用したほうが良いでしょう。

> わたし:  
修正作業にあたっていただきありがとうございます。今回修正していただいた内容に関してより良くなる点を見つけました。
- `main_program.py`に計測結果の標準出力をパースするプログラムがありますね。メイン部分で直接処理せずに、`raw_data_module.py`で処理するとより良いです。
- この部分はすでに私が修正しましたが、`store_results`関数の引数`iterations`は今回の測定だけではなく、もしそれまでに計測を行っていれば、その測定回数も含める必要があるので、`raw_data`テーブルに存在したエントリー数に更新することが正しいです。
上記のポイントを元にプログラムを修正してください。

## 10. 実行プログラムをbuildディレクトリから参照して設定用YAMLファイルを作成する

> わたし:  
尽力いただき感謝します。こちらで少し修正しましたがほぼ問題ない内容でした。  
さて、次の作業をしましょう。  
次の作業目標は、設定用YAMLファイルを元にデータベースを初期化することです。

現在`lib/build/`には`cblas_col_speed_test`, `cblas_row_speed_test`, `cublas_speed_test`の3つがあります。そのため設定用YAMLを`run_config.yml`に書きました。確認してください。
このファイルの設定を読み出してデータベースを初期化するように`initialize_parameters.py`を編集してください。

> わたし:  
良い作業内容だと思います。ありがとうございました。
さて、次は`main_program.py`を編集してください。
- 設定YAMLファイルから読み込むようにしてください。
- `main()`の引数をプログラム名と、イテレーション回数にしてください。
- 引数のプログラム名と、設定ファイルの`name`と合致する内容を読み込むようにしてください。
- `main()`内部で`init`以外の設定内容を保持するようにしてください。
上記内容に準じるよう`main_program.py`を変更するために計画を立案してください。

## 11. YAMLファイルから対応する実行計画データベースを作成する: initialize_parameters.pyを実行する
> わたし:  
ありがとうございます。すこし編集したので、適宜`git diff`などのコマンドで現在の状況を確認してください。
次のタスクからプログラムの検証を行います。
まず、`initialize_parameters.py`を実行して、適切にパラメタデータベースが作成されることを確認してください。

> わたし:  
上手く実行できないようですね。実行結果をコンテクストに注入したいですが。。では私がそのプログラムを実行するので、動作を確認することはできますか？

> わたし:  
プログラムを実行したら次のエラーが発生しました。
```shell
$ python3 python/initialize_parameters.py 
An error occurred while connecting to SQLite: ON CONFLICT clause does not match any PRIMARY KEY or UNIQUE constraint
Traceback (most recent call last):
  File "/home/msakamoto/test/cublas_speed_test/python/initialize_parameters.py", line 18, in <module>
    initialize_from_config()
  File "/home/msakamoto/test/cublas_speed_test/python/initialize_parameters.py", line 15, in initialize_from_config
    initialize_parameters(db_path, m_list, n_list, k_list)
  File "/home/msakamoto/test/cublas_speed_test/python/parameter_database_module.py", line 40, in initialize_parameters
    cursor.executemany('''
sqlite3.OperationalError: ON CONFLICT clause does not match any PRIMARY KEY or UNIQUE constraint
```

> わたし:  
かならずM, N, Kをキーとして参照しなければならないので、テーブル作成時にUNIQUEを追加してみました。すると上手く行ったようです。

## 12. `critical_params.yml`を読み込んでスケジュールデータベースの優先度を更新する関数を作成する

> わたし:  
素晴らしいです。プログラムが動き始めましたね。次は少し、プログラムに機能を追加しましょう。
`critical_params.yml`を読み込んでスケジュールデータベースの優先度を更新する関数を作成してください。
まずは作成するための計画を立てましょう。

> わたし:  
良いですね！でもより具体的な計画にしてみましょう。どのファイル、どの関数を作成、変更しますか？

> わたし:
完璧です！ではその方針で仕事を始めましょう。